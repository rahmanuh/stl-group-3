import mtl

from databaseConnection import DatabaseConnection

# Exercise: STL Monitoring for a Gantry Crane Digital Twin
"""
Prerequisites:
1. Make sure that you are connected to the university of Antwerp network (either local or via VPN)
2. Tunnel the database connection over SSH:
ssh -L 5432:localhost:5432 -i ~/.ssh/certificate username@143.129.43.20
* where username is your username on the netlab server
* where certificate is the ssh private key for the netlab server
3. Make sure that the requirements.txt dependencies are installed (IDEs like pycharm will do this for you)

Learning Objectives:
1. Understand and implement safety monitoring using STL
2. Progress from basic to complex temporal properties

Background:
- A gantry crane moves containers along a rail (x-direction)
- Key measurements: position (x) and swing angle (θ). They come from the database connection
- Safe operation requires monitoring multiple properties

Worked Example - Monitoring Angular Position Bounds:
Step 1: Convert numerical signal to boolean signal
    - We need to check if |θ| ≤ 0.095 at all times
    - Create a lambda function that takes (time, value) pairs and returns (time, boolean)

Step 2: Write the STL formula
    - We want the |θ| ≤ 0.095 to hold for all time points
    - Use the G (globally) operator

Step 3: Combine in the monitoring function
    - Create data dictionary with our boolean signal
    - Apply the STL formula and check result
"""


class CraneMonitor(object):
    def __init__(self):
        # Worked Example: Angular Position Bounds
        # Step 1: Lambda function to check bounds
        self.theta_within_bounds = lambda lst: [(t, abs(entry) <= 0.095) for (t, entry) in lst]

        # Step 2: STL formula - should always be within bounds
        self.theta_bounds_check = mtl.parse('G(theta_bound)')
        # theta_bound is the key of a dictionary with the value: a list of (time,value)-pairs
        # For step 3 goto def check_theta_bounds(self, theta):

        # Now it's your turn! Complete the following exercises...
        # Part 1: Basic Safety Bounds
        # Exercise 1.1: Operation domain: Position bounds checking: Postion should never be smaller than 0.0
        # or larger than 0.45; Same as, always has to be in range [0.0, 0.45].
        # TODO: Create lambda function for position bounds [0.0, 0.45]
        self.x_within_min = lambda lst: [(t, x >= 0.0 ) for (t, x) in lst]
        self.x_within_max = lambda lst: [(t, x <= 0.45 ) for (t, x) in lst]

        # Exercise 1.2: Write STL formula for position bounds
        # TODO: Write your first STL formula. You want that the position never exceeds
        #  for the whole future.
        self.bounds_check = mtl.parse('G(min_x & max_x)')  # Your STL formula here

        #-----------------------------------
        # Part 2: Position-Based Properties
        # Exercise 2.1: Check if crane reaches target positions
        # The target position is a parameter, based on the trajectory (generated by the control component)
        # For this you need to also get trajectory information out of the database (the function is provided)
        # TODO: Implement check for:
        # - Reaching loading position (x = 0.0 ± 0.01)
        # - Reaching unloading position (x = end_pos ± 0.04)
        self.at_loading = lambda lst, start_position: [(t, abs(x - start_position) < 0.01) for (t, x) in lst]
        self.at_unloading = lambda lst, end_position: [(t, abs(x - end_position) < 0.04) for (t, x) in lst]
        # As the STL formula is dynamic (based on the time calculated by the trajectory planner),
        # We will put the formula in the check_proper_transport_sequence.

        # -----------------------------------
        # Part 3: Complex Dynamic Behavior
        # Exercise 3.1: Implement swing detection
        # TODO: Create lambda functions for:
        # - When arriving at the end of the trajectory, the swinging should end within 0.1 seconds
        # - Stable swing (|θ| ≤ 0.003)
        #self.swing_stable = lambda lst:  # Your code here
        #self.x_end_reached = lambda lst,end_pos: # Your code here

        # Exercise 3.2: Write STL formula for swing settling requirement
        # Advanced: After reaching the end position, swing should settle within 0.2s
        # and remain stable for at least 0.15s
        #self.settling_check = mtl.parse('')  # Your STL formula here

        #---------------------------------------
        # Part 4: Find another property you want to check. Make sure that it is a property that is impossible to achieve
        # Write the filters, property and checker for the property

    # Example monitoring method
    def check_theta_bounds(self, theta):
        '''
        Example monitoring method for angular position bounds
        param theta: list of (timestamp, value) pairs for angular position
        returns: bool: True if bounds are satisfied, False otherwise
        '''
        # Step 3: Create data dictionary with our boolean signal
        data = {}
        data['theta_bound'] = self.theta_within_bounds(theta)

        # Apply STL formula
        return self.theta_bounds_check(data, quantitative=False)

    def check_x_bounds(self, x):
        '''
        Example monitoring method for x position bounds
        param x: list of (timestamp, value) pairs for x position
        returns: bool: True if bounds are satisfied, False otherwise
        '''
        # Step 3: Create data dictionary with our boolean signal
        data = {}
        data['min_x'] = self.x_within_min(x)
        data['max_x'] = self.x_within_max(x)

        # Apply STL formula
        return self.bounds_check(data, quantitative=False)

    def check_proper_transport_sequence(self, x, traj_start, traj_end, max_t ):
        """

        :param x: list with pairs of (time, x(t))
        :param traj_start: start point of the trajectory
        :param traj_end: end point of the trajectory
        :param max_t: time needed to complete the trajectory
        :return: evlauation of the STL formula
        """
        # Exercise 2.2: Write STL formula for proper transport sequence
        # Hint: Use the F operator to check if positions are reached in sequence
        # The trajectory should be done within a certain timespan (trajectory_end - trajectory_start ± 0.2)
        # Because the formula is dynamic
        data = {}
        data['at_loading'] = self.at_loading(x, traj_start)
        data['at_unloading'] = self.at_unloading(x, traj_end)
        # For some reason, the F[0, max_t] does not work. Always returns error about parse error.
        # Because we know that max_t = 2.03 + 0.2, then we hardcoded it

        self.transport_sequence = mtl.parse('G(at_loading -> F[0, 2.23] at_unloading)')  # Your STL formula here


    def check_settling(self, x, theta):
        """
        Checks the settling time property.
        :param x: list with pairs of (time, x(t))
        :param theta: list with pairs of (time, theta(t))
        :return: evaluation of the STL formula
        """
        # Do the check.


dbc =DatabaseConnection()
measurements = dbc.get_measurement()
trajectory = dbc.get_trajectory()
cm = CraneMonitor()
angle_bounds_check =  cm.check_theta_bounds(measurements['angular position'])
print(f"Angle Bounds: {'✓' if angle_bounds_check else '✗'}")
bounds_check_x = cm.check_x_bounds(measurements['position'])
print(f"Position Bounds: {'✓' if bounds_check_x else '✗'}")

x = measurements['position']
start_traj = trajectory['position'][0][1]
end_traj = trajectory['position'][-1][1]
max_t = trajectory['position'][-1][0]
#print(max_t)

proper_transport_seq = cm.check_proper_transport_sequence(x, start_traj, end_traj, max_t)
print(f"Proper tranport: {'✓' if proper_transport_seq else '✗'}")